module ByteString =
struct
  include String

  let uget s i = ord (String.unsafe_get s i)
  let uset s i c = String.unsafe_set s i (chr c)

  let init f l =
    let s = create l in
    for i=0 to l-1 do uset s i (f i) done;
    s

  let make l i = make l (chr i)

  let reverse s =
    let len = length s in
    let s2 = create len in
    let mlen = len - 1 in
    for i=0 to mlen do
      uset s2 (mlen-i) (uget s i)
    done;
    s2
  let rev = reverse
  let len = length
  let normalizeIndex i s = if i < 0 then (len s) + i else i

  let map f s = init (fun i -> uget s i) (len s)
  let filter f s =
    let rec aux f s i res =
      if i < 0 then implode res
      else
        let c = uget s i in
        let res = if f c then (chr c)::res else res in
        aux f s (i-1) res in
    aux f s (len s - 1) []

  let zipWith f a b =
    let len = min (len a) (len b) in
    init (fun i -> f (uget a i) (uget b i) ) len
  let map2 = zipWith
  (**
    ByteString.zipWith (fun x y -> (x + y) / 2) "abc" "cde" = "bcd"
    ByteString.map2 (fun x y -> x) "foo" "barq" = "foo"
  **)

  let from_array a = init (Array.unsafe_get a) (Array.length a)
  let to_array s = ainit (uget s) (len s)

  let foldl f init s =
    let rec aux f s len v i =
      if i >= len then v else aux f s len (f v (uget s i)) (i+1) in
    aux f s (len s) init 0

  let foldl1 f a =
    let rec aux f i acc len a =
      if i >= len then acc
      else aux f (i+1) (f acc (uget a i)) len a in
    let len = len a in
    if len < 1 then raise Not_found;
    aux f 1 (uget a 0) len a

  let foldr f init s =
    let rec aux f s v i =
      if i < 0 then v else aux f s (f (uget s i) v) (i-1) in
    aux f s init (len s - 1)

  let foldr1 f a =
    let rec aux f i acc a =
      if i < 0 then acc
      else aux f (i-1) (f (uget a i) acc) a in
    let len = len a in
    if len < 1 then raise Not_found;
    aux f (len-2) (uget a (len-1)) a

  let substring i len s = String.sub s (normalizeIndex i s) len
  let sub = substring

  let groupsOf n a =
    let count, rem = quot_rem (len a) n in
    unfoldrWhile (gte 0) (fun i -> sub (i*n) n a, i-1) (count-1) @
    if rem = 0 then [] else [sub (-rem) rem a]
  let splitInto n range =
    let len = len range in
    let plen = int (ceil (float len /. float n)) in
    groupsOf plen range

  let sum a = foldl (+) 0 a
  let sumf a = float (foldl (+) 0 a)
  let average a = sum a / len a
  let averagef a = sumf a /. float (len a)
  let subStride stride i len a =
    let i = normalizeIndex i a in
    if i + (len-1) * stride >= length a
    then invalid_arg "ByteString.subStride: index out of bounds";
    init (fun j -> uget a (i + j*stride)) len

  let quote l r s = l ^ s ^ r

  let join = String.concat
  let join_array s a = join s (Array.to_list a)
  let concat = String.concat ""

  let slice i j s =
    let i = normalizeIndex i s
    and j = normalizeIndex j s + (if j < 0 then 1 else 0) in
    let len = j - i in
    String.sub s i len
  let sumSub i len a =
    let rec aux s i l c =
      if l = 0 then c else
      aux s (i+1) (l-1) (c + uget s i) in
    if i < 0 || len < 0 || i + len > length a
    then invalid_arg "ByteString.sumSub: index ouf of bounds"
    else aux a i len 0
  let sumSubf i len a = float (sumSub i len a)
  let sumSlice i j s =
    let i = normalizeIndex i s
    and j = normalizeIndex j s + (if j < 0 then 1 else 0) in
    let len = j - i in
    sumSub i len s
  let sumSlicef i len a = float (sumSlice i len a)
  let averageSub i len a = sumSub i len a / len
  let averageSubf i len a = sumSubf i len a /. float len
  let averageSlice i j s =
    let i = normalizeIndex i s
    and j = normalizeIndex j s + (if j < 0 then 1 else 0) in
    let len = j - i in
    sumSub i len s / len
  let averageSlicef i j s =
    let i = normalizeIndex i s
    and j = normalizeIndex j s + (if j < 0 then 1 else 0) in
    let len = j - i in
    float (sumSub i len s) /. float len

  let pick indices s = List.map (fun i -> get s i) indices
  let pickWith funcs s = List.map (fun f -> f s) funcs

  let par_mapReduce ?process_count ~combine ~process l =
    let process_count = process_count |? !global_process_count in
    splitInto process_count l |> par_map ~process_count process |> combine

  let pmapReduce combine process = par_mapReduce ~combine ~process

  let pfoldl r f init = pmapReduce (PList.foldl1 r) (foldl f init)
  let pfoldl1 f = pmapReduce (PList.foldl1 f) (foldl1 f)
  let pfoldr r f init = pmapReduce (PList.foldr1 r) (foldr f init)
  let pfoldr1 f = pmapReduce (PList.foldr1 f) (foldr1 f)

  let piter f = pmapReduce ignore (iter f)
  let pmap f = pmapReduce concat (map f)
  let pfilter f = pmapReduce concat (filter f)

  let pfoldlSeqN ?process_count n r f init l =
    PList.foldl (fun acc il -> r acc (pfoldl ?process_count r f init il))
          init (groupsOf n l)

  let piterSeqN ?process_count n r f l =
    PList.iter (fun l -> iter r (pmap ?process_count f l)) (groupsOf n l)

  let pinit ?process_count f l =
    let process_count = process_count |? !global_process_count in
    let plen = int (ceil (float l /. float process_count)) in
    let process i =
      let start = plen * i in
      let len = min plen (l - start) in
      init (fun j -> f (start + j)) len in
    concat (par_map ~process_count process (0--(process_count-1)))

  let pzipWith ?process_count f a b =
    let process_count = process_count |? !global_process_count in
    let len = min (length a) (length b) in
    pinit ~process_count (fun i ->
      f (unsafe_get a i) (unsafe_get b i)
    ) len
end
