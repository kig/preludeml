module type ARRAY_LIKE =
sig
  type 'a t
  val make : int -> 'a -> 'a t
  val length : 'a t -> int
  val unsafe_get : 'a t -> int -> 'a
  val unsafe_set : 'a t -> int -> 'a -> unit
end


let generateN f n =
  let rec aux f n res =
    if n < 0 then res
    else aux f (n-1) ((f n) :: res) in
  aux f (n-1) []

let quot_rem a b =
  let q = a / b in
  (q, a - (q*b))

let optIf p f v = if p v then Some (f v) else None

let gte x y = (>=) y x
let int = int_of_float

let unfoldrOpt f init =
  let rec aux f v l =
    match f v with
      | None -> l
      | Some (a, b) -> aux f b (a::l) in
  aux f init []

let unfoldr p f init = unfoldrOpt (optIf p f) init
let unfoldrWhile = unfoldr


module Make (Collection : ARRAY_LIKE) =
struct
  include Collection

  let len = length
  let uget = unsafe_get
  let uset = unsafe_set

  let init f l =
    let s = make l (f 0) in
    for i=1 to l-1 do uset s i (f i) done;
    s

  let range s e =
    if s > e
    then init ((-) s) (s-e+1)
    else init ((+) s) (e-s+1)

  let reverse s =
    let len = length s in
    if len = 0 then s else
    let s2 = make len (uget s 0) in
    let mlen = len - 1 in
    for i=0 to mlen do
      uset s2 (mlen-i) (uget s i)
    done;
    s2
  let rev = reverse
  let len = length
  let normalizeIndex i s = if i < 0 then (len s) + i else i

  let iter f s =
    let l = len s in
    for i = 0 to l - 1 do f (uget s i) done
  let iterWithIndex f s =
    let l = len s in
    for i = 0 to l - 1 do f (uget s i) i done

  let map f s = init (fun i -> f (uget s i)) (len s)
  let mapWithIndex f s = init (fun i -> f (uget s i) i) (len s)

  let to_array s = Array.init (len s) (uget s)
  let of_array arr = init (Array.unsafe_get arr) (Array.length arr)

  let to_list s = generateN (uget s) (len s)
  let of_list l = of_array (Array.of_list l)

  let filter f s =
    let rec aux f s i res =
      if i < 0 then of_list res
      else
        let c = uget s i in
        let res = if f c then c::res else res in
        aux f s (i-1) res in
    aux f s (len s - 1) []

  let filterWithIndex f s =
    let rec aux f s i res =
      if i < 0 then of_list res
      else
        let c = uget s i in
        let res = if f c i then c::res else res in
        aux f s (i-1) res in
    aux f s (len s - 1) []

  let findWithIndex f s =
    let rec aux f s i len =
      if i >= len then raise Not_found
      else
        let v = uget s i in
        if f v i then (v, i)
        else aux f s (i+1) len in
    aux f s 0 (len s)

  let find f s = fst (findWithIndex (fun v _ -> f v) s)
  let findIndex f s = snd (findWithIndex (fun v _ -> f v) s)

  let indexOf v s = findIndex ((=) v) s


  let zipWith f a b =
    let len = min (len a) (len b) in
    init (fun i -> f (uget a i) (uget b i) ) len
  let map2 = zipWith

  let zipWith3 f a b c =
    let len = min (min (len a) (len b)) (len c) in
    init (fun i -> f (uget a i) (uget b i) (uget c i) ) len
  let map3 = zipWith3


  let foldl f init s =
    let rec aux f s len v i =
      if i >= len then v else aux f s len (f v (uget s i)) (i+1) in
    aux f s (len s) init 0

  let foldl1 f a =
    let rec aux f i acc len a =
      if i >= len then acc
      else aux f (i+1) (f acc (uget a i)) len a in
    let len = len a in
    if len < 1 then raise Not_found;
    aux f 1 (uget a 0) len a

  let foldr f init s =
    let rec aux f s v i =
      if i < 0 then v else aux f s (f (uget s i) v) (i-1) in
    aux f s init (len s - 1)

  let foldr1 f a =
    let rec aux f i acc a =
      if i < 0 then acc
      else aux f (i-1) (f (uget a i) acc) a in
    let len = len a in
    if len < 1 then raise Not_found;
    aux f (len-2) (uget a (len-1)) a

  let maximum = foldl1 max
  let minimum = foldl1 min

  let maximumBy f = foldl1 (fun s i -> if (f s) < (f i) then i else s)
  let minimumBy f = foldl1 (fun s i -> if (f s) > (f i) then i else s)

  let sub i len s =
    let i = normalizeIndex i s in
    let slen = length s in
    let j = max (i+len-1) (slen-1) in
    init (fun x -> uget s (i+x)) (j-i+1)

  let take n s = sub 0 n s
  let takeWhile f s = sub 0 (findIndex (fun v -> not (f v)) s + 1) s

  let drop n s = sub (-n) n s
  let dropWhile f s = sub (findIndex (fun v -> not (f v)) s) (len s) s

  let splitAt n xs = (take n xs, drop n xs)

  let break f s = splitAt (findIndex f s) s
  let span f s = break (fun v -> not (f v)) s

  let interlace elem s =
    init (fun i -> if i mod 2 = 0 then uget s (i/2) else elem) (2 * len s - 1)

  let reject f s = filter (fun v -> not (f v)) s
  let without v s = filter ((<>) v) s

  let groupsOf n a =
    let count, rem = quot_rem (len a) n in
    unfoldrWhile (gte 0) (fun i -> sub (i*n) n a, i-1) (count-1) @
    if rem = 0 then [] else [sub (-rem) rem a]

  let splitInto n range =
    let len = len range in
    let plen = int (ceil (float len /. float n)) in
    groupsOf plen range

  let subStride stride i len a =
    let i = normalizeIndex i a in
    if i + (len-1) * stride >= length a
    then invalid_arg "subStride: index out of bounds";
    init (fun j -> uget a (i + j*stride)) len

  let slice_to_sub i j s =
    let i = normalizeIndex i s
    and j = normalizeIndex j s + (if j < 0 then 1 else 0) in
    let len = j - i in
    i, len

  let slice i j s =
    let i, len = slice_to_sub i j s in
    sub i len s

  let iterSub i len f s =
    let i = normalizeIndex i s in
    for j=i to i+len-1 do f (uget s j) done

  let iterSlice i j f s =
    let i, len = slice_to_sub i j s in
    iterSub i len f s

  let mapSub i len f s =
    let i = normalizeIndex i s in
    let slen = length s in
    let j = max (i+len-1) (slen-1) in
    init (fun j -> f (uget s (i+j))) (j-i)

  let mapSlice i j f s =
    let i, len = slice_to_sub i j s in
    mapSub i len f s

  let foldlSub i len f init s =
    let rec aux f s v i j =
      if i > j then v else aux f s (f v (uget s i)) (i+1) j in
    let i = normalizeIndex i s in
    let slen = length s in
    let j = max (i+len-1) (slen-1) in
    aux f s init i j

  let foldl1Sub i len f s =
    let i = normalizeIndex i s in
    if i < 0 || i >= length s then raise Not_found;
    foldlSub (i+1) (len-1) f (uget s i) s

  let foldrSub i len f init s =
    let rec aux f s v i j =
      if j < i then v else aux f s (f v (uget s j)) i (j-1) in
    let i = normalizeIndex i s in
    let slen = length s in
    let j = max (i+len-1) (slen-1) in
    aux f s init i j

  let foldr1Sub i len f s =
    let i = normalizeIndex i s in
    let j = i + len - 1 in
    if j < 0 || j >= length s then raise Not_found;
    foldrSub i (len-1) f (uget s j) s


  let foldlSlice i j f init s =
    let i, len = slice_to_sub i j s in
    foldlSub i len f init s

  let foldl1Slice i j f s =
    let i, len = slice_to_sub i j s in
    foldl1Sub i len f s

  let foldrSlice i j f init s =
    let i, len = slice_to_sub i j s in
    foldrSub i len f init s

  let foldr1Slice i j f s =
    let i, len = slice_to_sub i j s in
    foldr1Sub i len f s

  let sum a = foldl (+) 0 a
  let sumf a = foldl (+.) 0. a
  let product a = foldl ( * ) 1 a
  let productf a = foldl ( *. ) 1. a
  let average a = sum a / len a
  let averagef a = sumf a /. float (len a)

  let sumSub i len a = foldlSub i len (+) 0 a
  let sumSubf i len a = foldlSub i len (+.) 0. a

  let sumSlice i j a = foldlSlice i j (+) 0 a
  let sumSlicef i j a = foldlSlice i j (+.) 0. a

  let productSub i len a = foldlSub i len ( * ) 1 a
  let productSubf i len a = foldlSub i len ( *. ) 1. a

  let productSlice i j a = foldlSlice i j ( * ) 1 a
  let productSlicef i j a = foldlSlice i j ( *. ) 1. a

  let averageSub i len a = sumSub i len a / len
  let averageSubf i len a = sumSubf i len a /. float len

  let averageSlice i j s =
    let i, len = slice_to_sub i j s in
    averageSub i len s

  let averageSlicef i j s =
    let i, len = slice_to_sub i j s in
    averageSubf i len s

  let pick indices s =
    let l = len s in
    if List.exists (gte l) indices then invalid_arg "pick: Index out of bounds";
    List.map (fun i -> uget s i) indices

  let pickWith funcs s = List.map (fun f -> f s) funcs

  let concat xs =
    let xs = List.filter (fun x -> len x > 0) xs in
    let len = List.fold_left (fun s x -> s + len x) 0 xs in
    let res = make len (uget (List.hd xs) 0) in
    ignore (List.fold_left (fun s x ->
      let l = length x in
      for j=0 to l-1 do uset res (s+j) (uget x j) done;
      s + l
    ) 0 xs);
    res

end
